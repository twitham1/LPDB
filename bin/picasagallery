@rem = '--*-Perl-*--
@echo off
if "%OS%" == "Windows_NT" goto WinNT
perl -x -S "%0" %1 %2 %3 %4 %5 %6 %7 %8 %9
goto endofperl
:WinNT
perl -x -S %0 %*
if NOT "%COMSPEC%" == "%SystemRoot%\system32\cmd.exe" goto endofperl
if %errorlevel% == 9009 echo You do not have Perl in your PATH.
if errorlevel 1 goto script_failed_so_exit_with_non_zero_val 2>nul
goto endofperl
@rem ';
#!/usr/bin/perl
#line 15

# picasagallery by twitham@sbcglobal.net, 2013-12

# keyboard-driven mythgallery-style browser that understands Picasa:
# albums, faces, stars, uploads, captions, exif, tags, location, etc.

# TODO: add filtering by flags, age
# TODO: [random] slideshow below current point in tree w/ variable time
# TODO: toggle option to replace face thumbnails with zoomed face crops
# TODO: pop-up menu of all options and/or keyboard shortcut help
# TODO: support all Picasa file formats (videos for example) (help ->
#	options -> file types: jpe?g, bmp, gif, png, tga, tiff?, webp,
#	psd, (many raw), (movies: avi, mpg, asf, wmv)
# TODO: option to toggle full-screen mode
# TODO: add zoom/pan to image viewer
# TODO: add mouse/touch controls

use strict;
use warnings;
use Tk;
use Tk::Frame;
use Tk::JPEG;
use Tk::PNG;
use Tk::Bitmap;
use Tk::Pixmap;
use Tk::Photo;
use Tk::Font;
use Tk::Table;			 # for picture browser
use Data::Dumper;		 # for saving metadata cache
use File::Path;			 # for creating thumbnail paths
use Image::ExifTool qw(:Public); # for picture metadata
use Date::Calc qw/Delta_YMD Delta_Days/; # for age calculations
use Picasa;			 # for groking Picasa data!

my $picasa;			# working picasa database
my $picasa_tmp;			# picasa database while updating

# config file can override any settings here (Picasa.pm also uses some):
our $conf = {
    config	=> '.picasagallery_conf.pl', # config to require, if present
    metadata	=> '.picasagallery_cache.pl', # cache of picture data
    cache	=> '.thumbcache', # where to put thumbnails
    keep	=> '(?i)\.(jpe?g|gif|x[pb]m|png|bmp|tiff?|nef)$',
    reject	=> '(?i)\b(thumbs?(.db)?|desktop.ini)\b',
    datefmt	=> '%Y-%m-%d %H:%M:%S %a', # must be sortable w/year first
    update	=> \&update,		# don't change this (GUI updates)
    debug	=> 0,			# debug to STDERR?
    info	=> 0,			# overlay metadata on images?
    width	=> 1280,		# initial size
    height	=> 720,
    fullscreen	=> 0, # go full-screen with no borders (ignore width/height)?
    birthday	=> {}, # optional contact(id|name) => 'yyyy/mm/dd' birthdays
    bg		=> 'black',	# background color for the application
    select	=> 'green',	# current thumbnail selection color
    text	=> 'white',	# corner information text color
    title	=> 'red',	# header/footer color
    face	=> 'magenta', # face box color (uncommon picture color)
};

require $conf->{config} if -f $conf->{config}; # start with previous run data:
$picasa = require $conf->{metadata} if -f $conf->{metadata};

my $refreshing = '';		# directory currently refreshing

$Data::Dumper::Indent = 1;   # readable format for the cached metadata

my $mw = Tk::MainWindow->new (-title => "Picasa Gallery", -bg => $conf->{bg});
my($mx, $my) = ($conf->{width}, $conf->{height});
if ($conf->{fullscreen}) {
    ($mx, $my) = ($mw->screenwidth, $mw->screenheight);
    warn "going fullscreen to $mx x $my\n" if $conf->{debug};
    $mw->overrideredirect(1); # must be done before window is mapped
}
$mw->geometry(sprintf "%dx%d", $mx, $my);

mkdir $conf->{cache} or die $! unless -d $conf->{cache};

my $exif = new Image::ExifTool;
$exif->Options(FastScan => 1,
	       DateFormat => $conf->{datefmt});

my(@tn);		       # thumbnails: array of labels of Photos
my $tnx = 7;		       # columns of thumbnails to display
my $tpx = int(($mx - 4 * $tnx - 50) / $tnx); # 50 should be actual scroll bar width intead
my $tpy = int($tpx / 1.1);	# "average" aspect ratio for most pics

# text metadata in corners of browser
my($nw, $n, $ne, $se, $s, $sw) = ('', '', '', '', '', '');
# maybe font should be replaced on <configure> window resize...
my $big = $mw->Font(-family => 'Helvetica',
		    -size => int($my / 40), # 20,
		    -weight => 'bold',
    );
my $med = $mw->Font(-family => 'Helvetica',
		    -size => int($my / 50), # 15,
#		    -weight => 'bold',
    );

my @c = (-fg => $conf->{text}, -bg => $conf->{bg});
my $top = $mw->Frame(@c)->pack(-side => "top", -fill => 'x');
$top->Label(-textvariable => \$nw, -font => $med, @c)->pack(-side => "left");
$top->Label(-textvariable => \$ne, -font => $med, @c)->pack(-side => "right");
$top->Label(-textvariable => \$n,  -font => $big, @c, -fg => $conf->{title})->pack(-side => "top");

my $bot = $mw->Frame(@c)->pack(-side => "bottom", -fill => 'x');
$bot->Label(-textvariable => \$sw, -font => $med, @c)->pack(-side => "left");
$bot->Label(-textvariable => \$se, -font => $med, @c)->pack(-side => "right");
$bot->Label(-textvariable => \$s,  -font => $med, @c, -fg => $conf->{title})->pack(-side => "bottom");

# thumbnail table grid
my $tg = $mw->Table(-rows => 4,
		    -columns => 7,
		    -scrollbars => 'w',
		    -bg => $conf->{bg},
    )->pack(-side => "top", -expand => 1, -fill => "both");

# full size image viewer
my $full = $mw->Toplevel(-width => $mx, -height => $my, -bg => $conf->{bg});
$full->overrideredirect(1) if $conf->{fullscreen};
my $canvas = $full->Canvas(-width => $mx, -height => $my, -bg => $conf->{bg},
			   -highlightthickness=> 0, -borderwidth => 0)
    ->pack(-side => 'top', -anchor => 'nw', -expand => 1, -fill => 'both');
my $image = $mw->Photo(-width => $mx, -height => $my);
$image->blank;
$canvas->createImage(0, 0, -image => $image, -anchor => 'nw');
$mw->raiseFocus;

$full->bind('<Configure>' => 	# resize window
	    sub  { my $w = shift;
		   ($mx, $my) = ($w->Width, $w->Height);
		   $canvas->configure(-width => $mx,
				      -height => $my);
		   $image->configure(-width => $mx,
				     -height => $my);
		   &newpic;
	    });
for my $w ($mw, $full) {
#    $w->bind('<KeyPress>', [\&processkey, Ev('A'), Ev('k'), Ev('K'), Ev('N')]);

    for (qw(<Key-q> <Escape>)) {
	$w->bind($_, sub {	# up or exit
	    my $tmp = $mw->focusCurrent;
	    if ($mw->focusCurrent eq $full) {
		$mw->raiseFocus;
	    } elsif ($picasa->{dir}{file} eq '/') {
		$full->destroy;
		$mw->destroy;
		if ($picasa->{done} and
		    open my $fh, '>', "$conf->{metadata}~") {
		    print $fh Dumper $picasa or die $!;
		    close $fh and rename "$conf->{metadata}~",
		    $conf->{metadata} or die $!;
		}
		exit;
	    } else {
		$picasa->up;
		&newdir;
	    }
	    &move;
		 });
    }
    for (qw(<Key-d> <Return>)) {
	$w->bind($_, sub {	# enter subdirectory or full picture
	    if ($picasa->down) {
		$mw->raiseFocus;
		&newdir;
	    } else {
		$full->raiseFocus;
		&newpic;
	    }
	    &move;
		 });
    }
    for (qw(<Right> <space> <Key-n>)) {
	$w->bind($_, sub {	# next picture or subdir
	    $picasa->next;
	    &newpic;
	    &move;
		 });
    }
    for (qw(<Left> <Up> <BackSpace> <Key-p>)) {
	$w->bind($_, sub {	# previous picture or subdir
	    $picasa->prev;
	    &newpic;
	    &move;
		 });
    }
    for (qw(<Down>)) {
	$w->bind($_, sub {	# next row
	    $picasa->next($tnx);
	    &newpic;
	    &move;
		 });
    }
    for (qw(<Up>)) {
	$w->bind($_, sub {	# previous row
	    $picasa->prev($tnx);
	    &newpic;
	    &move;
		 });
    }
    for (qw(<Next>)) {
	$w->bind($_, sub {	# next page
	    $picasa->next($tnx * 4);
	    &newpic;
	    &move;
		 });
    }
    for (qw(<Prior>)) {
	$w->bind($_, sub {	# previous page
	    $picasa->prev($tnx * 4);
	    &newpic;
	    &move;
		 });
    }
    for (qw(<Key-i>)) {
	$w->bind($_, sub {	# information toggle
	    $conf->{info} = $conf->{info} ? 0 : 1;
	    &newpic;
	    &move;
		 });
    }
    for (qw(<Key-1>)) {
	$w->bind($_, sub {	# information toggle
	    warn "key 1 hit\n";
	    $conf->{filter} =~ s/f// or
		$conf->{filter} .= 'f';
	    &newdir;
	    &newpic;
		 });
    }
}

warn "starting Picasa recursion\n" if $conf->{debug};
$picasa_tmp = Picasa->new($conf); # rebuild all data since prior run
$picasa or $picasa = $picasa_tmp; # keep previous run or use first run live
$mw->after(500, \&newdir);	# show browser after we have some data
$picasa_tmp->recursedirs('.');	# updates GUI via $conf->{update}
warn "Picasa recursion done!\n" if $conf->{debug};

if ($picasa_tmp->{done} && $picasa ne $picasa_tmp) {
    warn "replacing $picasa with $picasa_tmp\n" if $conf->{debug};
    my $old = $picasa;
    $picasa_tmp->{index} = $picasa->{index}; # retain current location
    $picasa_tmp->{dir} = $picasa->{dir};
    $picasa_tmp->{file} = $picasa->{file};
    $picasa = $picasa_tmp;
    undef $old;			# free previous data, now stale
}

MainLoop;			# never returns
exit;				# should never get here

sub processkey {
    my($win, $ascii, $code, $str, $num) = @_;
    warn "'$ascii $code $str $num' was pressed\n";
}

BEGIN {	# filtering for stats is expensive, so we update GUI only once a second
    my $updated = 0;
    sub update {
	$mw->update;		# let GUI work while we are busy
	return unless time > $updated;
	return unless $picasa_tmp->{root};
	return unless $picasa_tmp->{file};
	return unless $picasa_tmp->{file}{dir};
	return unless $picasa_tmp->{file}{file};

	warn "updating $File::Find::name\n" if $conf->{debug};
	my $loc = "$picasa_tmp->{file}{dir}$picasa_tmp->{file}{file}";
	$picasa_tmp->{file} = $picasa_tmp->filter($loc);
	&move;			# updates statistics on GUI
	$updated = time;
    }
}

sub nums {			# format the counts of attributes
    my $this = shift;
    my $out = sprintf "%ds %du %df %da %dc",
    $this->{stars},
    $this->{uploads},
    scalar @{$this->{faces}},
    scalar @{$this->{albums}},
    $this->{caption} =~ /^\d+$/ ? $this->{caption} :
	$this->{caption} ? 1 : 0;
    return $out =~ /[1-9]/ ? $out : '';
}

sub stats {			# format the [average] image metrics
    my($this, $x, $y) = @_;
    my $w = $this->{width} / $this->{files};
    my $h = $this->{height} / $this->{files};
    my $scale = $x / $w < $y / $h ? $x / $w : $y / $h;

    return sprintf "%.0f KB (%.2f MP) %.0f x %.0f (%.3f) %.0f%%",
    $this->{bytes} / 1024 / $this->{files},
    $this->{pixels} / 1000 / 1000 / $this->{files},
    $w, $h, $w / $h, 100 * $scale;
}

sub move {			# move to new directory or file
    return unless $picasa->{index} >= 0;

    $mw->title("PG: $picasa->{file}{dir}");
    $tg->see(int($picasa->{index} / $tnx + 1), # Table index begins at 1, not 0!
	     $picasa->{index} % $tnx + 1);

    return unless my $current = $picasa->{file};
    warn "location: $picasa->{dir}{dir} $picasa->{dir}{file} - $picasa->{file}{dir} $picasa->{file}{file} ($picasa->{index})\n" if $conf->{debug};
    return unless $current->{files};

    for my $i (0 .. $#tn) {
	my $w = $tg->get(int($i / $tnx + 1), $i % $tnx + 1);
	$w->configure(-bg => $conf->{bg});
	$w->configure(-bg => $conf->{select}) if $i == $picasa->{index};
    }

    $n = $current->{file};
    $n =~ s/$current->{time}-// unless $n =~ m!/$!;

    $nw = sprintf "%.2f MB (%.2f GP) in %d files",
    $current->{bytes} / 1024 / 1024,
    $current->{pixels} / 1000 / 1000 / 1000,
    $current->{files};
    my $tmp = &nums($current);
    $nw .= " ($tmp)" if $tmp;

    $ne = &stats($current, $tpx, $tpy);

    my $total = @{$picasa->{dir}{children}};
    my $cur = $picasa->{index} + 1;
    $s = "$current->{dir}: $cur / $total";

    $sw = $current->{time};
    $se = $current->{time} eq $current->{endtime} ?
	$current->{caption} || '' : $current->{endtime};
}

sub newdir {		 # replace all thumbnails in current directory
    my $now = "$picasa->{dir}{dir}$picasa->{dir}{file}";
    $now =~ s@/+@/@g;
    $refreshing eq $now and return;
    warn "\n\nnewdir $now\n" if $conf->{debug};
    $refreshing = $now;
    $mw->raiseFocus;

    # Gather all pics in this folder
    my $index = 0;
    &move;
    # my $f = $conf->{filter};	# save
    # $conf->{filter} = '';	# remove filters for all pics
    # my $all = $picasa->filter($now);
    # warn "all: $all\n";
    # $conf->{filter} = $f;	# restore
    # foreach my $img (@{$all->{children}}) {
    foreach my $img (@{$picasa->{dir}{children}}) {
	my $now = "$picasa->{dir}{dir}$picasa->{dir}{file}";
	$now =~ s@/+@/@g;
	$refreshing eq $now or return;

        my $child = "$now$img";
	my $this = $picasa->filter($child) or next;
	my $pf = $this->{physical} or next;
        my $ps = -s $pf or next;
	my $data = $picasa->{pics}{$pf} or next; # data of this picture
	my $x = $data->{width} or next;
	my $y = $data->{height} or next;

	unless ($tn[$index]) { # connect 1 photo to each cell only once
	    $tn[$index] = $tg->Label(-width => $tpx, -height => $tpy, -image =>
				     $mw->Photo(-width => $tpx, -height => $tpy),
				     -bg => $conf->{bg});
	    $tg->put(int($index / $tnx) + 1, # Table index begins at 1, not 0!
		     $index % $tnx + 1,
		     $tn[$index]);
	}
	my $image = $tn[$index]->cget(-image); # replace cell's photo
	if ($img =~ m!/$!) {	# directory: stack some pics
	    $child =~ s@/$@@;
	    $image->StackXYthumb($child, $tpx, $tpy, "$this->{files}: $img",
				 $this->{first}, $this->{physical}, $this->{'last'});
	} else {
	    my $scale = $tpy / $y < $tpx / $x ? $tpy / $y : $tpx / $x;
	    $image->PhotoXYthumb($pf, (map { int } $scale * $x, $scale * $y),
				 $data->{caption} || 0);
	}

#	warn "putting $index / $tnx ($w in $tg - $t - $pf)\n" if $conf->{debug} > 1;
        $tn[$index]->update;	# Display the thumbnail
	$index++;
    }
    while ($index <= $#tn) {	# blank the unused cells
    	$tn[$index++]->cget(-image)->blank;
    }
    &move;
    $refreshing = "";
}

sub newpic {	     # replace the full picture with current selection
    $full->focusCurrent eq $full or return;
    my $this = $picasa->{file} or return;
    if ($this->{file} =~ m!/$!) { # raise browser to see directory option
	&newdir;
	return;
    }
    my $pf = $this->{physical} or return;
    my $ps = -s $pf or return;
    my $data = $picasa->{pics}{$pf} or return; # data of this picture
    my $x = $data->{width} or return;
    my $y = $data->{height} or return;
    my $scale = $mx / $x < $my / $y ? $mx / $x : $my / $y;
    my($X, $Y) = $image->PhotoXYfull($pf, map { int } $scale * $x, $scale * $y)
	or return;
    $full->title("PG: $picasa->{file}{file}");

    $canvas->delete('exif');
    $canvas->delete('caption');
    $canvas->delete('info');
    $canvas->delete('faces');
    return unless $conf->{info};

    if (my $info = $exif->ImageInfo($pf)) {
	my @info;
	push @info, $info->{Make} if $info->{Make};
	push @info, $info->{Model} if $info->{Model};
	push @info, "$info->{ExposureTime}s" if $info->{ExposureTime};
	push @info, $info->{FocalLength} if $info->{FocalLength};
	push @info, "($info->{FocalLengthIn35mmFormat})" if $info->{FocalLengthIn35mmFormat};
	push @info, "f/$info->{FNumber}" if $info->{FNumber};
	push @info, "ISO: $info->{ISO}" if $info->{ISO};
	push @info, $info->{Flash} if $info->{Flash};
	$canvas->createTextBox($mx, $my, $conf->{bg},
			       -justify => 'right',
			       -anchor => 'se',
			       -font => $med,
			       -fill => $conf->{text},
			       -text => (join " \n", @info),
			       -tags => 'exif');
    }
    $canvas->createTextBox($mx, 0, $conf->{bg},
			   -justify => 'right',
			   -anchor => 'ne',
			   -font => $med,
			   -fill => $conf->{text},
			   -text => &stats($this, $mx, $my),
			   -tags => 'info');
    (my $file = $this->{file}) =~ s/$this->{time}-//;
    my $text = "$this->{dir}\n$file\n$this->{time}";
    $text .= "\n$this->{endtime}" if $this->{time} ne $this->{endtime};
    my $tmp = &nums($this);
    $text .= "\n($tmp)" if $tmp;
    $canvas->createTextBox(0, 0, $conf->{bg},
			   -anchor => 'nw',
			   -font => $med,
			   -fill => $conf->{text},
			   -text => $text,
			   -tags => 'info');
    $text = join "\n", map { $picasa->{album}{$_}{name} } @{$this->{albums}};
    $canvas->createTextBox(0, $my, $conf->{bg},
			   -anchor => 'sw',
			   -font => $med,
			   -fill => $conf->{text},
			   -text => $text,
			   -tags => 'info');

    my $total = @{$picasa->{dir}{children}};
    my $cur = $picasa->{index} + 1;
    $canvas->createTextBox($mx / 2, 0, $conf->{bg},
			   -anchor => 'n',
			   -font => $med,
			   -fill => $conf->{title},
			   -text => "$cur / $total",
			   -tags => 'info');
    my $bar = $mx / $total;	# disappearing "progress" bar!
    $bar = 5 if $bar < 5;	# TODO: all info could disappear...
    my $id = $canvas->createLine($bar * $picasa->{index}, 2,
    				 $bar * $picasa->{index} + $bar, 2,
    				 -fill => $conf->{title},
    				 -width => 5,
    				 -tags => 'info');
#    $full->after(3000, sub { $canvas->delete($id) });

    if ($this->{caption}) {
	$canvas->createTextBox($mx / 2, $my, $conf->{bg},
			       -anchor => 's',
			       -font => $med,
			       -fill => $conf->{title},
			       -text => $this->{caption},
			       -tags => 'caption');
    }

    for my $f (@{$this->{faces}}) { # named rectangles around faces!
	next unless ref $f;
	my($id, $l, $t, $r, $b) = @$f;
	my $name = $picasa->contact2person($id);
	$canvas->createRectangle($X + $l * $x * $scale, $Y + $t * $y * $scale,
				 $X + $r * $x * $scale, $Y + $b * $y * $scale,
				 -outline => $conf->{face},
				 -tags => 'faces');
	$canvas->createText($X + $l * $x * $scale + 2, $Y + $t * $y * $scale,
			    -anchor => 'nw',
			    -font => $med,
			    -fill => $conf->{face},
			    -text => $name,
			    -tags => 'faces');
	if (my $birth = $conf->{birthday}{$id} # show ages of faces :-)
	    || $conf->{birthday}{$name}) {
	    my($yr, $m, $d) = split '/', $birth;
	    my($Yr, $M, $D) = split /\D+/, $this->{time};
	    my($year, $mon, $day) = Delta_YMD($yr, $m, $d, $Yr, $M, $D);
	    warn "age $id/$name: $Yr, $M, $D - $yr, $m, $d = $year, $mon, $day\n"
		if $conf->{debug};
	    my $age;
	    if ($year < 1 && $mon < 3) {
		$age = sprintf "%dd", Delta_Days($yr, $m, $d, $Yr, $M, $D);
	    } elsif ($year < 3) {
		$age = sprintf "%dm", int($year * 12 + $mon);
	    } else {
		$age = sprintf "%d", int($year + $mon / 12 + $day / 365);
	    }
	    $canvas->createText($X + $r * $x * $scale - 2, $Y + $b * $y * $scale,
				-justify => 'right',
				-anchor => 'se',
				-font => $big,
				-fill => $conf->{face},
				-text => $age,
				-tags => 'faces');
	}
    }
}

# read $f file into $w image scaled to size $x / $y, with cacheing
sub Tk::PhotoXYthumb {
    my ($w, $f, $x, $y, $c) = @_;
    $f && $x && $y or return;
    my $ext = 'jpg';		# jpg is smaller than png
    my $cfn = "$conf->{cache}/$f-$x-$y.$ext";
    unless (-f $cfn && -M _ <= -M $f) {
	my($dir, $file) = Picasa::dirfile($cfn);
	-d $dir or mkpath $dir or warn "can't mkdir $dir: $!\n";
	my $geo = "${x}x${y}";
	if ($c) {
	    system qw/convert -fill white -gravity center -background/,
	    '#0006', '-size', $tpx . 'x' . int($tpy / 6), "caption:$c", $f,
	    '-thumbnail', $geo, qw/+swap -gravity south -composite/, $cfn;
	} else {
	    system qw/convert -thumbnail/, $geo, $f, $cfn;
	}
	my($time) = (stat $f)[9]; # timestamp same as source file
	utime $time, $time, $cfn;
    }
    $w->blank;
    $w->read($cfn, -to => int(($tpx - $x) / 2), int(($tpy - $y) / 2));
}

# @pics stacked into $w image of size $x / $y, with cacheing as $f
sub Tk::StackXYthumb {
    my ($w, $f, $x, $y, $label, @pic) = @_;
#    warn "StackXYthumb: my ($w, $f, $x, $y, $label, @pic)\n" if $conf->{debug};
    $f && $x && $y && @pic or return;
    my $ext = 'png';		# jpg isn't transparent; use png
    my $cfn = "$conf->{cache}/$f-$x-$y.$ext";
    
    unless (-f $cfn && @pic == grep { -M $_ >= -M $cfn } @pic) {
	my($dir, $file) = Picasa::dirfile($cfn);
	-d $dir or mkpath $dir or warn "can't mkdir $dir: $!\n";
	my $geo = sprintf "%.0fx%.0f", $x * 2 / 3, $y * 2 / 3;
	system 'convert', '-size', "${x}x${y}", 'xc:#0000',
	'(', $pic[0], '-thumbnail', $geo, ')', qw/-gravity northwest -composite/,
	'(', $pic[1], '-thumbnail', $geo, ')', qw/-gravity center -composite/,
	'(', $pic[2], '-thumbnail', $geo, ')', qw/-gravity southeast -composite/,
	qw/-fill white -gravity center -background/, '#0006', '-size', 
	sprintf("%.0fx%.0f", $x, $y / 5), "caption:$label", '-composite', $cfn;
	my($time) = sort { $b <=> $a } map { (stat $_)[9] } @pic; # latest
	utime $time, $time, $cfn;
    }
    $w->blank;
    $w->read($cfn);
}


# read $f file into $w image scaled to size $x / $y
BEGIN {
    my $id = 10000;
    my $ext = 'jpg';		# full format
    sub Tk::PhotoXYfull {
	my ($w, $f, $x, $y) = @_;
	$f && $x && $y or return;
	my $cfn = "$conf->{cache}/tmp-$$-" . $id++ . ".$ext";
	my $geo = "${x}x${y}";
	system "convert", "-resize", $geo, $f, $cfn;
	my($l, $t) = (int(($mx - $x) / 2), int(($my - $y) / 2));
	$w->blank;
	$w->read($cfn, -to => $l, $t);
	unlink $cfn;
	return $l, $t;
    }
}

# createText on a box of given color $c
sub Tk::Canvas::createTextBox {
    my($w, $x, $y, $c, %opt) = @_;
    my $t = $w->createText($x, $y, %opt);
    my @opt;
    push @opt, (-tags => $opt{'-tags'}) if $opt{'-tags'};
    $w->createRectangle($w->bbox($t), -fill => $c, @opt);
    $w->raise($t);
}

# raise window $w and ensure it has focus
sub Tk::raiseFocus {
    my($w) = @_;
    $w->deiconify;
    $w->raise;
    if ($conf->{fullscreen}) {	# force needed on Linux
	$w->focusForce;		# with overrideredirect(1)
	$w->grabGlobal;
    }
}

__END__
:endofperl
